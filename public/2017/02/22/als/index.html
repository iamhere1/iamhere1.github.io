<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="推荐算法,协同过滤,矩阵分解,隐语义模型," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="als算法学习与实践">
<meta name="keywords" content="推荐算法,协同过滤,矩阵分解,隐语义模型">
<meta property="og:type" content="article">
<meta property="og:title" content="ALS推荐算法学习与实践">
<meta property="og:url" content="http://learning.github.com/2017/02/22/als/index.html">
<meta property="og:site_name" content="个人学习博客">
<meta property="og:description" content="als算法学习与实践">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-02-07T16:02:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ALS推荐算法学习与实践">
<meta name="twitter:description" content="als算法学习与实践">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> ALS推荐算法学习与实践 | 个人学习博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">个人学习博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ALS推荐算法学习与实践
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-22T00:00:00+08:00" content="2017-02-22">
              2017-02-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/推荐系统/" itemprop="url" rel="index">
                    <span itemprop="name">推荐系统</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2017/02/22/als/" class="leancloud_visitors" data-flag-title="ALS推荐算法学习与实践">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX"],
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML,http://myserver.com/MathJax/config/local/local.js">
</script>


<p>ALS（alternating least squares）是一种基础的推荐算法，相对于普通的协同过滤等方法，它不仅能通过降维增加模型的泛化能力，也方便加入其他建模因素（如数据偏差、时间、隐反馈等），大大提升了模型的灵活性。正因为此，ALS算法在Netflix推荐大赛中脱颖而出，在我们具体的工程实践中，也具有非常不错的表现。接下来，从如下几个方面和大家一起学习：ALS算法模型、spark ALS源码理解， ALS推荐实践。如描述有误，欢迎大家指正。</p>
<h1 id="ALS算法模型"><a href="#ALS算法模型" class="headerlink" title="ALS算法模型"></a>ALS算法模型</h1><h2 id="为什么要用ALS模型"><a href="#为什么要用ALS模型" class="headerlink" title="为什么要用ALS模型"></a>为什么要用ALS模型</h2><p> 相对于其他模型，ALS模型优势如下：</p>
<ul>
<li><p><strong>相对于基于内容的推荐</strong>，ALS属于协同过滤大家族【1】【12】（也有人认为ALS 基于矩阵分解技术，不属于协同过滤范畴【2】），<strong>直接跟进用户行为信息进行建模，不需要获取user和item的内容信息</strong>（很多情况下这些内容信息并不是很好获取，但是相对基于内容的推荐，ALS存在冷启动问题）</p>
</li>
<li><p><strong>相对于传统的协同过滤推荐方法（user based、item based）</strong>， ALS算法属于factor model, 通过将数据从原始空间映射到更低维度空间，<strong>去除噪声信息，利用更主要的语义信息对问题建模，能获得更好的推荐效果</strong>。</p>
</li>
<li><p><strong>相对于svd分解模型而言</strong>， 两种模型都属于 factor model, 但<strong>svd分解模型更倾向于解决矩阵元素没有缺失的情况， 而通过一定的方式去填充矩阵不仅需要额外的填充成本，填充本身可能影响了数据的真实性</strong>。因此，直接对已知元素进行建模，是一种不错的思路。如【1，3-6】，直接对rating矩阵已知元素$r_{ui}$进行建模:</p>
</li>
</ul>
<center><br>$\sum_{u,i\in\mathbb K} (r_{ui} -<br>p_u^Tq_i)^2 + \lambda(p_u^Tp_u+q_i^Tq_i)$ （1）<br></center>

<ul>
<li>针对所建模型1可以用SGD或ALS 两种算法求解。其中<strong>sgd方法相对比较简单，但是当我们要建模的矩阵中已知元素较多时（如隐反馈），采用sgd在每次迭代都要求解所有元素，其时间复杂度是非常大的</strong>。ALS算法在求解某个user （或item）向量时，不依赖其他任何user（item）向量，这个性质使得<strong>ALS算法在每次迭代过程中方便并行化求解，在解决大规模矩阵分解问题时非常具有优势</strong>。 </li>
</ul>
<h2 id="ALS模型有什么缺点"><a href="#ALS模型有什么缺点" class="headerlink" title="ALS模型有什么缺点"></a>ALS模型有什么缺点</h2><p> 相对于其它推荐算法，ALS模型具有非常明显的优势：不需要对user和item信息进行建模，能够更加灵活地对各种因素建模，方便大规模并行计算。但ALS模型在如下几方面，又有自己的局限性：</p>
<ul>
<li><p>冷启动问题</p>
<p>包括user的冷启动和item的冷启动。由于rating矩阵的构建，依赖user的显式和隐式反馈信息，对于新的user和item，或者没有相关行为的user或item, 导致无法构建rating矩阵，或者rating矩阵构建不合理。</p>
<p>基于内容的推荐能较好地解决冷启动相关问题。如【8】在解决用户的冷启动问题时，首先根据用户之间社交的亲密度，对用户进行聚类，利用相同群体的用户画像来建模自身兴趣。同时，对于item的冷启动问题，可利用item本身对一些关键词、类目、内容等相关信息进行建模。【9】为了提高用户兴趣的准确率和覆盖率，在对用户兴趣建模对时候，将用户兴趣进行更具体的分类（如消费兴趣、生产兴趣、具体的每个行为兴趣等），并针对具体的业务，采用线性回归的方法对各种兴趣利用线性回归的方式进行加权求和，提升用户兴趣准确率和覆盖率。</p>
</li>
<li><p>用户临时兴趣</p>
<p>用户的兴趣是在不断变换的。对于相对较稳定的兴趣，ALS算法可以通过引入时间因素进行建模，如公式4。 但对于临时的兴趣变换，ALS算法是无法捕获的。</p>
<p><strong>一种简单且有效的方法</strong></p>
<p>将item划分为多个类别，每个类别对应一种兴趣。用户每次点击某个类别的item之后，认为该用户存在一种临时兴趣，通过动态增加相应类别的比例的item，迎合用户当前的消费需求。该方法的难点在于如何调整比例，才能让用户感到有很多自己喜欢的item, 同时又不会让用户感觉内容的单调。</p>
<p><strong>淘宝的一些实践</strong></p>
<p>为了有效获取用户的即时兴趣，给用户推荐最合适的产品，淘宝进行了比较多的实践【10】，分别如下所述。</p>
<ul>
<li><p>GBDT+FTRL模型</p>
<p>由于GBDT模型比较擅长挖具有区分度的特征，其使用GBDT模型进行特征挖掘，将得到的特征输送给FTRL进行在线学习。输送给GBDT的特征包括两部分：一部分用户基础行为的次数、CTR等；另一部分是来自match粗选阶段的的特征，该部分特征来自不同的粗选模型输出.</p>
</li>
<li><p>Wide &amp; Deep Learning模型</p>
<p>借鉴google论文思想【11】，利用wide模型 + deep模型 + LR，其中wide子结构通过特征交叉学习特征间的共现，deep子结构则输入具有泛化能力的离散特征和连续特征，wide模型和deep模型学习到的结果，再利用LR模型预测相应的得分。</p>
</li>
<li><p>Adaptive-Online-Learning</p>
<p>保留每一时刻学习到的模型，根据业务指标，得到每个模型等权重信息，融合出最优的结果。该方法能够比较好地综合利用用户长期喝短期兴趣。</p>
</li>
<li><p>Reinforcement Learning</p>
<p>该方法思想是通过定义每个步骤的奖励，当用户每次到来的时候，根据用户的累积奖励值，进行个性化推荐。</p>
</li>
</ul>
<p><strong>腾讯的LSTM实践</strong></p>
<p>  为解决音乐的推荐问题，腾讯采用的是LSTM深度学习方法【12】，将用户听的歌曲序列，抽取特征输入到LSTM网络进行训练。为防止有些用户对应的歌曲序列较短问题，其对这些数据的训练采用特殊处理，相关数据缺失的序列不进行状态更新。同时，为加快训练速度，将每次权值的训练过程通过矩阵的方式实现并发计算。另外，为降低soft max过程时间复杂度，采用Hierarchical softmax过程替代普通的softmax。</p>
</li>
</ul>
<h2 id="ALS模型是什么"><a href="#ALS模型是什么" class="headerlink" title="ALS模型是什么"></a>ALS模型是什么</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>ALS模型属于隐语义模型，通过对用户行为矩阵R进行矩阵分解，得到user factor向量矩阵P、item factor向量矩阵Q. </p>
<p>$R = P^T Q$ 。其中R、$P^T$、$Q^T$矩阵的定义如表1-表3所示。</p>
<p>潜在语义空间对应的各个factor代表不同的属性信息，user向量描述了user对各种属性的喜好程度，item向量描述了item所具备的各种属性强度，二者在潜在语义空间的相似度描述了user对item的喜好程度,在进行推荐时，根据该喜好程度计算推荐结果。</p>
<center>表1: rating矩阵R</center>

<table>
<thead>
<tr>
<th></th>
<th>item1</th>
<th>item2</th>
<th>item3</th>
<th>item4</th>
</tr>
</thead>
<tbody>
<tr>
<td>user1</td>
<td>$r_{11}$</td>
<td>$r_{12}$</td>
<td>$r_{13}$</td>
<td>$r_{14}$</td>
</tr>
<tr>
<td>user2</td>
<td>$r_{21}$</td>
<td>$r_{22}$</td>
<td>$r_{23}$</td>
<td>$r_{24}$</td>
</tr>
<tr>
<td>user3</td>
<td>$r_{31}$</td>
<td>$r_{32}$</td>
<td>$r_{33}$</td>
<td>$r_{34}$</td>
</tr>
<tr>
<td>user4</td>
<td>$r_{41}$</td>
<td>$r_{42}$</td>
<td>$r_{43}$</td>
<td>$r_{44}$</td>
</tr>
<tr>
<td>user5</td>
<td>$r_{51}$</td>
<td>$r_{52}$</td>
<td>$r_{53}$</td>
<td>$r_{54}$</td>
</tr>
</tbody>
</table>
<center>表2：user矩阵$P^T$</center>

<table>
<thead>
<tr>
<th></th>
<th>factor1</th>
<th>factor2</th>
<th>factor3 </th>
</tr>
</thead>
<tbody>
<tr>
<td>user1</td>
<td>$p_{11}$</td>
<td>$p_{12}$</td>
<td>$p_{13}$</td>
</tr>
<tr>
<td>user2</td>
<td>$p_{21}$</td>
<td>$p_{22}$</td>
<td>$p_{23}$</td>
</tr>
<tr>
<td>user3</td>
<td>$p_{31}$</td>
<td>$p_{32}$</td>
<td>$p_{33}$</td>
</tr>
<tr>
<td>user4</td>
<td>$p_{41}$</td>
<td>$p_{42}$</td>
<td>$p_{43}$</td>
</tr>
<tr>
<td>user5</td>
<td>$p_{51}$</td>
<td>$p_{52}$</td>
<td>$p_{53}$</td>
</tr>
</tbody>
</table>
<center>表3:item矩阵$Q^T$</center>

<table>
<thead>
<tr>
<th></th>
<th>factor1</th>
<th>factor2</th>
<th>factor3 </th>
</tr>
</thead>
<tbody>
<tr>
<td>item1</td>
<td>$q_{11}$</td>
<td>$q_{12}$</td>
<td>$q_{13}$</td>
</tr>
<tr>
<td>item2</td>
<td>$q_{21}$</td>
<td>$q_{22}$</td>
<td>$q_{23}$</td>
</tr>
<tr>
<td>item3</td>
<td>$q_{31}$</td>
<td>$q_{32}$</td>
<td>$q_{33}$</td>
</tr>
<tr>
<td>item4</td>
<td>$q_{41}$</td>
<td>$q_{42}$</td>
<td>$q_{43}$</td>
</tr>
</tbody>
</table>
<h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>$MIN_{PQ} \sum_{u,i\in\mathbb K} {(r_{ui} -<br>p_u^Tq_i）}^2 + \lambda(p_u^Tp_u+q_i^Tq_i)$  (2)</p>
<p>其中${(r_{ui} - p_u^Tq_i）}^2$ 目的在于最小化分解误差，$\lambda(p_u^Tp_u+q_i^Tq_i)$ 为正则项。</p>
<h3 id="目标函数求解"><a href="#目标函数求解" class="headerlink" title="目标函数求解"></a>目标函数求解</h3><p>由于目标函数中$p_u, q_i$都是未知变量，该问题是非凸的。当我们固定其中一个变量，解另外一个变量时，问题则变成凸问题，这是ALS求解的主要思想。在实际求解过程中分为如下几个步骤：</p>
<ol>
<li><p>随机初始化所有的变量$p_u, q_i$。</p>
</li>
<li><p>固定所有的$q_i$变量，求得$q_i$变量为当前值时$p_u$的最优值。</p>
</li>
<li><p>固定所有的$p_u$变量，求得$p_u$变量为当前值时$q_i$的最优值。</p>
</li>
<li><p>如果满足终止条件，则终止。否则，迭代执行2，3两步。</p>
</li>
</ol>
<p>通过不断执行步骤2和步骤3，使得误差越来越小，直到收敛或达到指定次数而终止。通过可导函数性质我们知道，当对变量求导结果等于0当时候，函数可以取得极值。具体到公式2，固定一个变量，对另一变量求导结果等于0时，可以达到极小值。</p>
<p>我们令$L = \sum_{u,i\in\mathbb K} {(r_{ui} - p_u^Tq_i）}^2 + \lambda(p_u^Tp_u+q_i^Tq_i)$</p>
<p>固定所有$q_i$, 对$p_u$求导</p>
<p>$-\frac{\alpha L}{2\alpha p_{uk}} = \sum_{i} {q_{ik}(r_{ui} - p_u^Tq_i）} - \lambda p_{uk} = 0$</p>
<p>=&gt; $\sum_{i} {q_{i}(r_{ui} - p_u^Tq_i）} - \lambda p_{u} = 0$</p>
<p>=&gt; $(\sum_{i} {q_i q_i^T} + \lambda E) p_u = \sum_{i}q_i r_{ui}$</p>
<p>=&gt; $p_u = (\sum_{i} {q_i q_i^T} + \lambda E)^{-1}\sum_{i}q_i r_{ui}$</p>
<p>=&gt; $ p_u = (Q_{u,i\in\mathbb K} Q_{u,i\in\mathbb K}^T + \lambda E)^{-1}Q_{u,i\in\mathbb K}R_{u,i\in\mathbb K}^T$</p>
<p>其中，$q_{u,i\in\mathbb K}$ 表示和user $u$有行为关联的item对应的向量矩阵，$r_{u,i\in\mathbb K}^T$表示和user $u$有行为关联的item对应rating元素构成的向量的转置。</p>
<p><strong>更加灵活的ALS建模</strong></p>
<p>相对于传统的协同协同过滤方法，ALS能更好的考虑其他因素，如数据偏差、时间等</p>
<ol>
<li><p>引入数据偏差</p>
<p> user偏差：不同的用户，可能具有不同的评分标准。如用户在给item打分时，有的用户可能可能更倾向于给所有item打高分， 而有的挑剔用户会给所有item打分偏低</p>
<p> item偏差：有的热门item可能所有用户都会倾向于打高分，而有的item可能本身大多数人会倾向于打低分</p>
<p> 考虑use和item偏差的ALS建模：<br> $MIN_{PQB} \sum_{u,i\in\mathbb K} {(r_{ui} - u - b_u - b_i-<br>p_u^Tq_i）}^2 + \lambda(p_u^Tp_u+q_i^Tq_i+b_u^2+b_i^2)$  (3)</p>
</li>
<li><p>引入时间因素</p>
<p> 用户偏好、rating矩阵，都可能随时间变化，item对应的属性不随时间变化，因此可进行如下建模<br>$MIN_{PQB} \sum_{u,i\in\mathbb K} {(r_{ui}（t） - u - b_u(t) - b_i(t)-<br>p_u(t)^Tq_i）}^2 + \lambda(p_u(t)^Tp_u(t)+q_i^Tq_i+b_u(t)^2+b_i(t)^2)$  (4)</p>
</li>
<li><p>引入隐反馈数据因素</p>
<p> 很多时候，并没有用户对item明确的打分数据，此时可通过搜集用户隐反馈数据（浏览、点击、点赞等），进行隐反馈建模。有一点需要注意，此时不只是对$r_{ui}$大于0对用户行为建模，而是所有$r_{ui}$元素建模。模型如公式5所示：</p>
<p> $MIN_{PQB} \sum_{u,i} {c_{ui}(p_{ui} - u - b_u - b_i-<br>p_u^Tq_i）}^2 + \lambda(p_u^Tp_u+q_i^Tq_i+b_u^2+b_i^2)$  (5)</p>
<p> $p_{ui}$ 表示user u是否有相关行为表示喜欢item i, $c_{ui}$描述user u 对item i的喜欢程度，其定义如公式6和公式7所示</p>
<p> $<br>p_{ui} =<br>\begin{cases}<br>1,  &amp; r_{ui}&gt;0\\<br>0,  &amp; r_{ui}=0<br>\end{cases}<br>$（6）</p>
<p> $c_{ui} = 1 + \alpha r_{ui}$（7）</p>
</li>
</ol>
<h1 id="spark-ALS源码理解"><a href="#spark-ALS源码理解" class="headerlink" title="spark ALS源码理解"></a>spark ALS源码理解</h1><p>为加深对ALS算法的理解，该部分主要分析spark mllib中ALS源码的实现，大体上分为2部分：ALS模型训练、ALS模型推荐</p>
<h2 id="ALS-模型训练"><a href="#ALS-模型训练" class="headerlink" title="ALS 模型训练"></a>ALS 模型训练</h2><h3 id="ALS-伴生类"><a href="#ALS-伴生类" class="headerlink" title="ALS 伴生类"></a>ALS 伴生类</h3><p>ALS 伴生对象提供外部调用 ALS模型训练的入口。通过传入相关参数， 返回训练好的模型对象MatrixFactorizationModel。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ALS</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">train</span></span>(</span><br><span class="line">      ratings: <span class="type">RDD</span>[<span class="type">Rating</span>], <span class="comment">//rating元素 （user, item, rate）</span></span><br><span class="line">      rank: <span class="type">Int</span>, <span class="comment">//隐语义个数</span></span><br><span class="line">      iterations: <span class="type">Int</span>, <span class="comment">//迭代次数</span></span><br><span class="line">      lambda: <span class="type">Double</span>, <span class="comment">//正则惩罚项</span></span><br><span class="line">      blocks: <span class="type">Int</span>, <span class="comment">//数据block个数</span></span><br><span class="line">      seed: <span class="type">Long</span> <span class="comment">//随机数种子</span></span><br><span class="line">    ): <span class="type">MatrixFactorizationModel</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ALS</span>(blocks, blocks, rank, iterations, lambda, fALSe, <span class="number">1.0</span>, seed).run(ratings)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">trainImplicit</span></span>(</span><br><span class="line">      ratings: <span class="type">RDD</span>[<span class="type">Rating</span>], <span class="comment">// rating元素 （user, item, rate）</span></span><br><span class="line">      rank: <span class="type">Int</span>, <span class="comment">//隐语义个数</span></span><br><span class="line">      iterations: <span class="type">Int</span>, <span class="comment">//迭代次数</span></span><br><span class="line">      lambda: <span class="type">Double</span>, <span class="comment">//正则惩罚项</span></span><br><span class="line">      blocks: <span class="type">Int</span>, <span class="comment">//数据block个数</span></span><br><span class="line">      alpha: <span class="type">Double</span> <span class="comment">//计算$c_ui$时用的alpha参数</span></span><br><span class="line">    ): <span class="type">MatrixFactorizationModel</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ALS</span>(blocks, blocks, rank, iterations, lambda, <span class="literal">true</span>, alpha).run(ratings)</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//另外还有一些其他接口，因最终都通过调用上面2个函数，此处将其省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ALS-私有类"><a href="#ALS-私有类" class="headerlink" title="ALS 私有类"></a>ALS 私有类</h3><p>定义了ALS类对应的各个参数，以及各个参数的设定方法。并定义了run方法供伴随类进行调用，该方法返回训练结果MatrixFactorizationModel给ALS伴随类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ALS</span> <span class="title">private</span> (<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    private var numUserBlocks: <span class="type">Int</span>, //用户数据block个数</span></span></span><br><span class="line"><span class="class"><span class="params">    private var numProductBlocks: <span class="type">Int</span>, //item数据block个数</span></span></span><br><span class="line"><span class="class"><span class="params">    private var rank: <span class="type">Int</span>, //隐语义个数</span></span></span><br><span class="line"><span class="class"><span class="params">    private var iterations: <span class="type">Int</span>, //迭代次数</span></span></span><br><span class="line"><span class="class"><span class="params">    private var lambda: <span class="type">Double</span>, //正则惩罚项</span></span></span><br><span class="line"><span class="class"><span class="params">    private var implicitPrefs: <span class="type">Boolean</span>, //是否使用隐反馈模型</span></span></span><br><span class="line"><span class="class"><span class="params">    private var alpha: <span class="type">Double</span>, //计算$c_ui$时用的alpha参数</span></span></span><br><span class="line"><span class="class"><span class="params">    private var seed: <span class="type">Long</span> = <span class="type">System</span>.nanoTime(</span>) <span class="title">//随机数种子</span>,<span class="title">默认为当前时间戳</span></span></span><br><span class="line"><span class="class">  ) <span class="keyword">extends</span> <span class="title">Serializable</span> <span class="keyword">with</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置block个数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setBlocks</span></span>(numBlocks: <span class="type">Int</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = &#123;</span><br><span class="line">    <span class="keyword">this</span>.numUserBlocks = numBlocks</span><br><span class="line">    <span class="keyword">this</span>.numProductBlocks = numBlocks</span><br><span class="line">    <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 另外对其他参数变量也有相关函数实现，因基本都是赋值操作，此处将其省略</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//run方法，通过输入rating数据，完成训练兵返回结果MatrixFactorizationModel</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ratings: <span class="type">RDD</span>[<span class="type">Rating</span>]): <span class="type">MatrixFactorizationModel</span> = &#123;</span><br><span class="line">    require(!ratings.isEmpty(), <span class="string">s"No ratings available from <span class="subst">$ratings</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sc = ratings.context</span><br><span class="line">    <span class="comment">//设置user block个数</span></span><br><span class="line">    <span class="keyword">val</span> numUserBlocks = <span class="keyword">if</span> (<span class="keyword">this</span>.numUserBlocks == <span class="number">-1</span>) &#123;</span><br><span class="line">      math.max(sc.defaultParallelism, ratings.partitions.length / <span class="number">2</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.numUserBlocks</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置item block个数</span></span><br><span class="line">    <span class="keyword">val</span> numProductBlocks = <span class="keyword">if</span> (<span class="keyword">this</span>.numProductBlocks == <span class="number">-1</span>) &#123;</span><br><span class="line">      math.max(sc.defaultParallelism, ratings.partitions.length / <span class="number">2</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.numProductBlocks</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用NewALS.train方法完成矩阵分解，生成user factor和item factor向量,该方法是整个ALS算法的核心实现</span></span><br><span class="line">    <span class="keyword">val</span> (floatUserFactors, floatProdFactors) = <span class="type">NewALS</span>.train[<span class="type">Int</span>](</span><br><span class="line">      ratings = ratings.map(r =&gt; <span class="type">NewALS</span>.<span class="type">Rating</span>(r.user, r.product, r.rating.toFloat)),</span><br><span class="line">      rank = rank,</span><br><span class="line">      numUserBlocks = numUserBlocks,</span><br><span class="line">      numItemBlocks = numProductBlocks,</span><br><span class="line">      maxIter = iterations,</span><br><span class="line">      regParam = lambda,</span><br><span class="line">      implicitPrefs = implicitPrefs,</span><br><span class="line">      alpha = alpha,</span><br><span class="line">      nonnegative = nonnegative,</span><br><span class="line">      intermediateRDDStorageLevel = intermediateRDDStorageLevel,</span><br><span class="line">      finalRDDStorageLevel = <span class="type">StorageLevel</span>.<span class="type">NONE</span>,</span><br><span class="line">      checkpointInterval = checkpointInterval,</span><br><span class="line">      seed = seed)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">val</span> userFactors = floatUserFactors</span><br><span class="line">      .mapValues(_.map(_.toDouble))</span><br><span class="line">      .setName(<span class="string">"users"</span>)</span><br><span class="line">      .persist(finalRDDStorageLevel)</span><br><span class="line">    <span class="keyword">val</span> prodFactors = floatProdFactors</span><br><span class="line">      .mapValues(_.map(_.toDouble))</span><br><span class="line">      .setName(<span class="string">"products"</span>)</span><br><span class="line">      .persist(finalRDDStorageLevel)</span><br><span class="line">    <span class="keyword">if</span> (finalRDDStorageLevel != <span class="type">StorageLevel</span>.<span class="type">NONE</span>) &#123;</span><br><span class="line">      userFactors.count()</span><br><span class="line">      prodFactors.count()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成和返回ALS模型 MatrixFactorizationModel</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">MatrixFactorizationModel</span>(rank, userFactors, prodFactors)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NewALS-train方法"><a href="#NewALS-train方法" class="headerlink" title="NewALS.train方法"></a>NewALS.train方法</h3><p>被ALS私有类的run方法调用，用于计算user factor和item factor向量。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span></span>[<span class="type">ID</span>: <span class="type">ClassTag</span>]( <span class="comment">// scalastyle:ignore</span></span><br><span class="line">      ratings: <span class="type">RDD</span>[<span class="type">Rating</span>[<span class="type">ID</span>]],</span><br><span class="line">      rank: <span class="type">Int</span> = <span class="number">10</span>,</span><br><span class="line">      numUserBlocks: <span class="type">Int</span> = <span class="number">10</span>,</span><br><span class="line">      numItemBlocks: <span class="type">Int</span> = <span class="number">10</span>,</span><br><span class="line">      maxIter: <span class="type">Int</span> = <span class="number">10</span>,</span><br><span class="line">      regParam: <span class="type">Double</span> = <span class="number">1.0</span>,</span><br><span class="line">      implicitPrefs: <span class="type">Boolean</span> = fALSe,</span><br><span class="line">      alpha: <span class="type">Double</span> = <span class="number">1.0</span>,</span><br><span class="line">      nonnegative: <span class="type">Boolean</span> = fALSe,</span><br><span class="line">      intermediateRDDStorageLevel: <span class="type">StorageLevel</span> = <span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK</span>,</span><br><span class="line">      finalRDDStorageLevel: <span class="type">StorageLevel</span> = <span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK</span>,</span><br><span class="line">      checkpointInterval: <span class="type">Int</span> = <span class="number">10</span>,</span><br><span class="line">      seed: <span class="type">Long</span> = <span class="number">0</span>L)(</span><br><span class="line">      <span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">ID</span>]): (<span class="type">RDD</span>[(<span class="type">ID</span>, <span class="type">Array</span>[<span class="type">Float</span>])], <span class="type">RDD</span>[(<span class="type">ID</span>, <span class="type">Array</span>[<span class="type">Float</span>])]) = &#123;</span><br><span class="line">    require(!ratings.isEmpty(), <span class="string">s"No ratings available from <span class="subst">$ratings</span>"</span>)</span><br><span class="line">    require(intermediateRDDStorageLevel != <span class="type">StorageLevel</span>.<span class="type">NONE</span>,</span><br><span class="line">      <span class="string">"ALS is not designed to run without persisting intermediate RDDs."</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = ratings.sparkContext</span><br><span class="line">    <span class="comment">//根据block个数，构建哈稀器。</span></span><br><span class="line">    <span class="keyword">val</span> userPart = <span class="keyword">new</span> <span class="type">ALSPartitioner</span>(numUserBlocks)</span><br><span class="line">    <span class="keyword">val</span> itemPart = <span class="keyword">new</span> <span class="type">ALSPartitioner</span>(numItemBlocks)</span><br><span class="line">    <span class="comment">//构建索引编码器，根据block编号和block内索引进行编码，同时可将编码后结果快速解码为block编号和block内索引号。具体实现是通过block个数，确定block编码需要的二进制位数，以及block内索引位数，通过这些位数利用逻辑操作即可实现编码和解码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userLocalIndexEncoder = <span class="keyword">new</span> <span class="type">LocalIndexEncoder</span>(userPart.numPartitions)</span><br><span class="line">    <span class="keyword">val</span> itemLocalIndexEncoder = <span class="keyword">new</span> <span class="type">LocalIndexEncoder</span>(itemPart.numPartitions)</span><br><span class="line">    <span class="comment">//构建求解器</span></span><br><span class="line">    <span class="keyword">val</span> solver = <span class="keyword">if</span> (nonnegative) <span class="keyword">new</span> <span class="type">NNLSSolver</span> <span class="keyword">else</span> <span class="keyword">new</span> <span class="type">CholeskySolver</span></span><br><span class="line">    <span class="comment">//对rating矩阵进行分块，得到((user_blockID, item_blockID),rating(user, item, rating))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> blockRatings = partitionRatings(ratings, userPart, itemPart)</span><br><span class="line">      .persist(intermediateRDDStorageLevel)</span><br><span class="line">    <span class="comment">//构建user inblock和outblock数据，inblock数据记录每个user对应的所有item的地址，及对应rating信息。 outblock记录当前block的哪些user数据会被哪些block用上</span></span><br><span class="line">    <span class="keyword">val</span> (userInBlocks, userOutBlocks) =</span><br><span class="line">      makeBlocks(<span class="string">"user"</span>, blockRatings, userPart, itemPart, intermediateRDDStorageLevel)</span><br><span class="line">    <span class="comment">// materialize blockRatings and user blocks</span></span><br><span class="line">    userOutBlocks.count()</span><br><span class="line">    <span class="comment">//交换blockrating中的user, item数据，用于构造item的inblcok和outblock信息</span></span><br><span class="line">    <span class="keyword">val</span> swappedBlockRatings = blockRatings.map &#123;</span><br><span class="line">      <span class="keyword">case</span> ((userBlockId, itemBlockId), <span class="type">RatingBlock</span>(userIds, itemIds, localRatings)) =&gt;</span><br><span class="line">        ((itemBlockId, userBlockId), <span class="type">RatingBlock</span>(itemIds, userIds, localRatings))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> (itemInBlocks, itemOutBlocks) =</span><br><span class="line">      makeBlocks(<span class="string">"item"</span>, swappedBlockRatings, itemPart, userPart, intermediateRDDStorageLevel)</span><br><span class="line">    <span class="comment">// materialize item blocks</span></span><br><span class="line">    itemOutBlocks.count()</span><br><span class="line">    <span class="keyword">val</span> seedGen = <span class="keyword">new</span> <span class="type">XORShiftRandom</span>(seed)</span><br><span class="line">    <span class="comment">//随机初始化user factor和item factor</span></span><br><span class="line">    <span class="keyword">var</span> userFactors = initialize(userInBlocks, rank, seedGen.nextLong())</span><br><span class="line">    <span class="keyword">var</span> itemFactors = initialize(itemInBlocks, rank, seedGen.nextLong())</span><br><span class="line">    <span class="keyword">var</span> previousCheckpointFile: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line">    <span class="keyword">val</span> shouldCheckpoint: <span class="type">Int</span> =&gt; <span class="type">Boolean</span> = (iter) =&gt;</span><br><span class="line">      sc.checkpointDir.isDefined &amp;&amp; checkpointInterval != <span class="number">-1</span> &amp;&amp; (iter % checkpointInterval == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> deletePreviousCheckpointFile: () =&gt; <span class="type">Unit</span> = () =&gt;</span><br><span class="line">      previousCheckpointFile.foreach &#123; file =&gt;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> checkpointFile = <span class="keyword">new</span> <span class="type">Path</span>(file)</span><br><span class="line">          checkpointFile.getFileSystem(sc.hadoopConfiguration).delete(checkpointFile, <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> e: <span class="type">IOException</span> =&gt;</span><br><span class="line">            logWarning(<span class="string">s"Cannot delete checkpoint file <span class="subst">$file</span>:"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//针对隐反馈，迭代求解</span></span><br><span class="line">    <span class="keyword">if</span> (implicitPrefs) &#123;</span><br><span class="line">      <span class="keyword">for</span> (iter &lt;- <span class="number">1</span> to maxIter) &#123;  <span class="comment">//迭代总次数maxIter</span></span><br><span class="line">        userFactors.setName(<span class="string">s"userFactors-<span class="subst">$iter</span>"</span>).persist(intermediateRDDStorageLevel)</span><br><span class="line">        <span class="keyword">val</span> previousItemFactors = itemFactors</span><br><span class="line">        <span class="comment">//固定user factor，优化item factor</span></span><br><span class="line">        itemFactors = computeFactors(userFactors, userOutBlocks, itemInBlocks, rank, regParam,</span><br><span class="line">          userLocalIndexEncoder, implicitPrefs, alpha, solver)</span><br><span class="line">        previousItemFactors.unpersist()</span><br><span class="line">        itemFactors.setName(<span class="string">s"itemFactors-<span class="subst">$iter</span>"</span>).persist(intermediateRDDStorageLevel)</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Generalize PeriodicGraphCheckpointer and use it here.</span></span><br><span class="line">        <span class="keyword">val</span> deps = itemFactors.dependencies</span><br><span class="line">        <span class="keyword">if</span> (shouldCheckpoint(iter)) &#123;</span><br><span class="line">          itemFactors.checkpoint() <span class="comment">// itemFactors gets materialized in computeFactors</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> previousUserFactors = userFactors</span><br><span class="line">        <span class="comment">//根据item factore, 优化user factor</span></span><br><span class="line">        userFactors = computeFactors(itemFactors, itemOutBlocks, userInBlocks, rank, regParam,</span><br><span class="line">          itemLocalIndexEncoder, implicitPrefs, alpha, solver)</span><br><span class="line">        <span class="keyword">if</span> (shouldCheckpoint(iter)) &#123;</span><br><span class="line">          <span class="type">ALS</span>.cleanShuffleDependencies(sc, deps)</span><br><span class="line">          deletePreviousCheckpointFile()</span><br><span class="line">          previousCheckpointFile = itemFactors.getCheckpointFile</span><br><span class="line">        &#125;</span><br><span class="line">        previousUserFactors.unpersist()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//针对显示反馈，迭代求解</span></span><br><span class="line">      <span class="keyword">for</span> (iter &lt;- <span class="number">0</span> until maxIter) &#123; <span class="comment">//迭代总次数maxIter</span></span><br><span class="line">        <span class="comment">//固定user factor，优化item factor</span></span><br><span class="line">        itemFactors = computeFactors(userFactors, userOutBlocks, itemInBlocks, rank, regParam,</span><br><span class="line">          userLocalIndexEncoder, solver = solver)</span><br><span class="line">        <span class="keyword">if</span> (shouldCheckpoint(iter)) &#123;</span><br><span class="line">          <span class="keyword">val</span> deps = itemFactors.dependencies</span><br><span class="line">          itemFactors.checkpoint()</span><br><span class="line">          itemFactors.count() <span class="comment">// checkpoint item factors and cut lineage</span></span><br><span class="line">          <span class="type">ALS</span>.cleanShuffleDependencies(sc, deps)</span><br><span class="line">          deletePreviousCheckpointFile()</span><br><span class="line">          previousCheckpointFile = itemFactors.getCheckpointFile</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据item factore, 优化user factor</span></span><br><span class="line">        userFactors = computeFactors(itemFactors, itemOutBlocks, userInBlocks, rank, regParam,</span><br><span class="line">          itemLocalIndexEncoder, solver = solver)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将user id 和 factor拼接在一起</span></span><br><span class="line">    <span class="keyword">val</span> userIdAndFactors = userInBlocks</span><br><span class="line">      .mapValues(_.srcIds)</span><br><span class="line">      .join(userFactors)</span><br><span class="line">      .mapPartitions(&#123; items =&gt;</span><br><span class="line">        items.flatMap &#123; <span class="keyword">case</span> (_, (ids, factors)) =&gt;</span><br><span class="line">          ids.view.zip(factors)</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Preserve the partitioning because IDs are consistent with the partitioners in userInBlocks</span></span><br><span class="line">      <span class="comment">// and userFactors.</span></span><br><span class="line">      &#125;, preservesPartitioning = <span class="literal">true</span>)</span><br><span class="line">      .setName(<span class="string">"userFactors"</span>)</span><br><span class="line">      .persist(finalRDDStorageLevel)</span><br><span class="line">    <span class="comment">//将item id 和 factor拼接在一起</span></span><br><span class="line">    <span class="keyword">val</span> itemIdAndFactors = itemInBlocks</span><br><span class="line">      .mapValues(_.srcIds)</span><br><span class="line">      .join(itemFactors)</span><br><span class="line">      .mapPartitions(&#123; items =&gt;</span><br><span class="line">        items.flatMap &#123; <span class="keyword">case</span> (_, (ids, factors)) =&gt;</span><br><span class="line">          ids.view.zip(factors)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, preservesPartitioning = <span class="literal">true</span>)</span><br><span class="line">      .setName(<span class="string">"itemFactors"</span>)</span><br><span class="line">      .persist(finalRDDStorageLevel)</span><br><span class="line">    <span class="keyword">if</span> (finalRDDStorageLevel != <span class="type">StorageLevel</span>.<span class="type">NONE</span>) &#123;</span><br><span class="line">      userIdAndFactors.count()</span><br><span class="line">      itemFactors.unpersist()</span><br><span class="line">      itemIdAndFactors.count()</span><br><span class="line">      userInBlocks.unpersist()</span><br><span class="line">      userOutBlocks.unpersist()</span><br><span class="line">      itemInBlocks.unpersist()</span><br><span class="line">      itemOutBlocks.unpersist()</span><br><span class="line">      blockRatings.unpersist()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回user factor和item factor数据</span></span><br><span class="line">    (userIdAndFactors, itemIdAndFactors)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建哈希器"><a href="#构建哈希器" class="headerlink" title="构建哈希器"></a>构建哈希器</h3><p>   构建哈希器，用于计算user或item id对应的block编号。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashPartitioner</span>(<span class="params">partitions: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">  require(partitions &gt;= <span class="number">0</span>, <span class="string">s"Number of partitions (<span class="subst">$partitions</span>) cannot be negative."</span>)</span><br><span class="line">  <span class="comment">//block总数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = partitions</span><br><span class="line">  <span class="comment">//通过求余计算block 编号</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = key <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="type">Utils</span>.nonNegativeMod(key.hashCode, numPartitions)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断2个哈希器是否相等</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equALS</span></span>(other: <span class="type">Any</span>): <span class="type">Boolean</span> = other <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> h: <span class="type">HashPartitioner</span> =&gt;</span><br><span class="line">      h.numPartitions == numPartitions</span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">      fALSe</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span></span>: <span class="type">Int</span> = numPartitions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建地址编码解码器"><a href="#构建地址编码解码器" class="headerlink" title="构建地址编码解码器"></a>构建地址编码解码器</h3><p>构建地址编码解码器，根据block编号和block内索引对地址进行编码，同时可将编码后地址解码为block编号和block内索引号。具体实现是通过block个数确定block编码需要的二进制位数，以及block内索引位数，通过这些位数利用逻辑操作即可实现地址的编码和解码。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[recommendation] <span class="class"><span class="keyword">class</span> <span class="title">LocalIndexEncoder</span>(<span class="params">numBlocks: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    require(numBlocks &gt; <span class="number">0</span>, <span class="string">s"numBlocks must be positive but found <span class="subst">$numBlocks</span>."</span>)</span><br><span class="line">    <span class="comment">//block内部索引使用的二进制位数</span></span><br><span class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">final</span> <span class="keyword">val</span> numLocalIndexBits =</span><br><span class="line">      math.min(java.lang.<span class="type">Integer</span>.numberOfLeadingZeros(numBlocks - <span class="number">1</span>), <span class="number">31</span>)</span><br><span class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">final</span> <span class="keyword">val</span> localIndexMask = (<span class="number">1</span> &lt;&lt; numLocalIndexBits) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据block编号和block内索引值，对地址编码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode</span></span>(blockId: <span class="type">Int</span>, localIndex: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">      require(blockId &lt; numBlocks)</span><br><span class="line">      require((localIndex &amp; ~localIndexMask) == <span class="number">0</span>)</span><br><span class="line">      (blockId &lt;&lt; numLocalIndexBits) | localIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据编码后地址，得到block编号</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blockId</span></span>(encoded: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">      encoded &gt;&gt;&gt; numLocalIndexBits</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据编码地址，得到block内部索引</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">localIndex</span></span>(encoded: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">      encoded &amp; localIndexMask</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="partition-rating"><a href="#partition-rating" class="headerlink" title="partition rating"></a>partition rating</h3><p>格式化rating数据，将rating数据分块，根据user和product的id哈希后的结果，得到对应的块索引。最终返回（src_block_id, dst_block_id）(src_id数组，dst_id数组，rating数组)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">partitionRatings</span></span>[<span class="type">ID</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      ratings: <span class="type">RDD</span>[<span class="type">Rating</span>[<span class="type">ID</span>]],</span><br><span class="line">      srcPart: <span class="type">Partitioner</span>,</span><br><span class="line">      dstPart: <span class="type">Partitioner</span>): <span class="type">RDD</span>[((<span class="type">Int</span>, <span class="type">Int</span>), <span class="type">RatingBlock</span>[<span class="type">ID</span>])] = &#123;</span><br><span class="line">    <span class="comment">//获得总block数</span></span><br><span class="line">    <span class="keyword">val</span> numPartitions = srcPart.numPartitions * dstPart.numPartitions</span><br><span class="line">    <span class="comment">//在rating的每个分区，计算每个rating元素对应的src_block_id和dst_block_id, 并放到对应的块索引中。然后，对所有分区的元素按照块索引进行聚合，并返回聚合结果</span></span><br><span class="line">    ratings.mapPartitions &#123; iter =&gt;</span><br><span class="line">      <span class="comment">//生成numPartitions个一维数组，存储对应block的rating记录</span></span><br><span class="line">      <span class="keyword">val</span> builders = <span class="type">Array</span>.fill(numPartitions)(<span class="keyword">new</span> <span class="type">RatingBlockBuilder</span>[<span class="type">ID</span>])</span><br><span class="line">      iter.flatMap &#123; r =&gt;</span><br><span class="line">        <span class="keyword">val</span> srcBlockId = srcPart.getPartition(r.user) <span class="comment">//user block id</span></span><br><span class="line">        <span class="keyword">val</span> dstBlockId = dstPart.getPartition(r.item) <span class="comment">//item block id</span></span><br><span class="line">        <span class="keyword">val</span> idx = srcBlockId + srcPart.numPartitions * dstBlockId <span class="comment">//数组索引计算</span></span><br><span class="line">        <span class="comment">//将对应的rating元素放在builders对应元素中</span></span><br><span class="line">        <span class="keyword">val</span> builder = builders(idx) </span><br><span class="line">        builder.add(r) </span><br><span class="line">        <span class="keyword">if</span> (builder.size &gt;= <span class="number">2048</span>) &#123; <span class="comment">// 2048 * (3 * 4) = 24k</span></span><br><span class="line">          <span class="comment">//如果某个block内数据量较多，直接得到结果</span></span><br><span class="line">          builders(idx) = <span class="keyword">new</span> <span class="type">RatingBlockBuilder</span></span><br><span class="line">          <span class="type">Iterator</span>.single(((srcBlockId, dstBlockId), builder.build()))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="type">Iterator</span>.empty</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; ++ &#123;</span><br><span class="line">        <span class="comment">//对builders数组内元素，计算对应的src_block_id和dst_block_id,并将对应rating数据放在其中</span></span><br><span class="line">        builders.view.zipWithIndex.filter(_._1.size &gt; <span class="number">0</span>).map &#123; <span class="keyword">case</span> (block, idx) =&gt;</span><br><span class="line">          <span class="keyword">val</span> srcBlockId = idx % srcPart.numPartitions</span><br><span class="line">          <span class="keyword">val</span> dstBlockId = idx / srcPart.numPartitions</span><br><span class="line">          ((srcBlockId, dstBlockId), block.build())</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.groupByKey().mapValues &#123; blocks =&gt;</span><br><span class="line">      <span class="comment">//对不同分区计算出的的rating元素进行聚合</span></span><br><span class="line">      <span class="keyword">val</span> builder = <span class="keyword">new</span> <span class="type">RatingBlockBuilder</span>[<span class="type">ID</span>]</span><br><span class="line">      blocks.foreach(builder.merge)</span><br><span class="line">      builder.build() <span class="comment">//value为 （src_id数组，dst_id数组，对应的rating数组）</span></span><br><span class="line">    &#125;.setName(<span class="string">"ratingBlocks"</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造in-block-和out-block"><a href="#构造in-block-和out-block" class="headerlink" title="构造in_block, 和out_block"></a>构造in_block, 和out_block</h3><p>在分布式计算中，不同节点的通信是影响程序效率重要原因，通过合理的设计分区，使得不同节点交换数据尽量少，可以有效的提升运行效率。</p>
<p>由上述章节中对目标函数求解推导，可以得知，每个用户向量的计算依赖于所有和它关联的item向量。如果不做任何优化，则每次优化user向量时，所有user向量的计算，都需要从其他节点得到对应item向量。如果节点A上有多个user和节点B上的某一item关联，则节点B需要向节点A传输多次item向量数据，实际上这是不必要的。优化的思路是，通过合理的分区，提前计算好所有节点需要从其它节点获取的item向量数据，将其缓存在本地，计算每个user向量时，直接从本地读取，可以大大减少需要传输的数据量，提升程序执行的效率。</p>
<p>在源码中，通过out block缓存当前节点需要向其它节点传输的数据， in block用于缓存当前节点需要的数据索引。当其他节点信息传输到本地时，通过读取in block内索引信息，来从本地获取其它节点传过来的数据。更加详细的描述可参考【7】</p>
<p>in block 结构： （block_id, Inblock(src_id数组, src_ptr, dst_id地址数组， rating数组）)<br>out block结构： （block_id， array[array[int]]） （二维数组存储发往每个block的src_id索引）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">makeBlocks</span></span>[<span class="type">ID</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      prefix: <span class="type">String</span>,</span><br><span class="line">      ratingBlocks: <span class="type">RDD</span>[((<span class="type">Int</span>, <span class="type">Int</span>), <span class="type">RatingBlock</span>[<span class="type">ID</span>])],</span><br><span class="line">      srcPart: <span class="type">Partitioner</span>,</span><br><span class="line">      dstPart: <span class="type">Partitioner</span>,</span><br><span class="line">      storageLevel: <span class="type">StorageLevel</span>)(</span><br><span class="line">      <span class="keyword">implicit</span> srcOrd: <span class="type">Ordering</span>[<span class="type">ID</span>]): (<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">InBlock</span>[<span class="type">ID</span>])], <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">OutBlock</span>)]) = &#123;</span><br><span class="line">    <span class="comment">//根据ratingBlocks.map计算inBlocks</span></span><br><span class="line">    <span class="keyword">val</span> inBlocks = ratingBlocks.map &#123;</span><br><span class="line">      <span class="keyword">case</span> ((srcBlockId, dstBlockId), <span class="type">RatingBlock</span>(srcIds, dstIds, ratings)) =&gt;</span><br><span class="line">        <span class="keyword">val</span> start = <span class="type">System</span>.nanoTime()</span><br><span class="line">        <span class="comment">//dst id去重复</span></span><br><span class="line">        <span class="keyword">val</span> dstIdSet = <span class="keyword">new</span> <span class="type">OpenHashSet</span>[<span class="type">ID</span>](<span class="number">1</span> &lt;&lt; <span class="number">20</span>) </span><br><span class="line">        dstIds.foreach(dstIdSet.add)  </span><br><span class="line">        <span class="comment">//dst id 去重结果进行排序</span></span><br><span class="line">        <span class="keyword">val</span> sortedDstIds = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">ID</span>](dstIdSet.size)</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> pos = dstIdSet.nextPos(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">          sortedDstIds(i) = dstIdSet.getValue(pos)</span><br><span class="line">          pos = dstIdSet.nextPos(pos + <span class="number">1</span>)</span><br><span class="line">          i += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        assert(i == dstIdSet.size)</span><br><span class="line">        <span class="type">Sorting</span>.quickSort(sortedDstIds)</span><br><span class="line">        <span class="comment">//得到dst id 对应的去重和排序后的索引值</span></span><br><span class="line">        <span class="keyword">val</span> dstIdToLocalIndex = <span class="keyword">new</span> <span class="type">OpenHashMap</span>[<span class="type">ID</span>, <span class="type">Int</span>](sortedDstIds.length)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; sortedDstIds.length) &#123;</span><br><span class="line">          dstIdToLocalIndex.update(sortedDstIds(i), i)</span><br><span class="line">          i += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        logDebug(</span><br><span class="line">          <span class="string">"Converting to local indices took "</span> + (<span class="type">System</span>.nanoTime() - start) / <span class="number">1e9</span> + <span class="string">" seconds."</span>)</span><br><span class="line">        <span class="keyword">val</span> dstLocalIndices = dstIds.map(dstIdToLocalIndex.apply)</span><br><span class="line">        (srcBlockId, (dstBlockId, srcIds, dstLocalIndices, ratings))</span><br><span class="line">    &#125;.groupByKey(<span class="keyword">new</span> <span class="type">ALSPartitioner</span>(srcPart.numPartitions)) <span class="comment">//根据src block id进行聚合</span></span><br><span class="line">      .mapValues &#123; iter =&gt;</span><br><span class="line">        <span class="keyword">val</span> builder =</span><br><span class="line">          <span class="keyword">new</span> <span class="type">UncompressedInBlockBuilder</span>[<span class="type">ID</span>](<span class="keyword">new</span> <span class="type">LocalIndexEncoder</span>(dstPart.numPartitions))</span><br><span class="line">        <span class="comment">//将dstBlockId和dstLocalIndices编码，并汇总数据</span></span><br><span class="line">        iter.foreach &#123; <span class="keyword">case</span> (dstBlockId, srcIds, dstLocalIndices, ratings) =&gt;</span><br><span class="line">          builder.add(dstBlockId, srcIds, dstLocalIndices, ratings)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对结果进行压缩存储，结果格式为（uniqueSrcId数组, dstPtrs数组, dstEncodedIndices数组, ratings数组）</span></span><br><span class="line">        builder.build().compress()</span><br><span class="line">      &#125;.setName(prefix + <span class="string">"InBlocks"</span>)</span><br><span class="line">      .persist(storageLevel)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//根据inBlocks计算outBlocks</span></span><br><span class="line">    <span class="keyword">val</span> outBlocks = inBlocks.mapValues &#123; <span class="keyword">case</span> <span class="type">InBlock</span>(srcIds, dstPtrs, dstEncodedIndices, _) =&gt;</span><br><span class="line">      <span class="comment">//构造编码器</span></span><br><span class="line">      <span class="keyword">val</span> encoder = <span class="keyword">new</span> <span class="type">LocalIndexEncoder</span>(dstPart.numPartitions)</span><br><span class="line">      <span class="comment">//定义ArrayBuilder数组，存储发往每个out block的 src id信息</span></span><br><span class="line">      <span class="keyword">val</span> activeIds = <span class="type">Array</span>.fill(dstPart.numPartitions)(mutable.<span class="type">ArrayBuilder</span>.make[<span class="type">Int</span>])</span><br><span class="line">      <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">      <span class="keyword">val</span> seen = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Boolean</span>](dstPart.numPartitions)</span><br><span class="line">      <span class="comment">//依次计算当前src id是否发往每一个block id</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; srcIds.length) &#123;</span><br><span class="line">        <span class="keyword">var</span> j = dstPtrs(i)</span><br><span class="line">        ju.<span class="type">Arrays</span>.fill(seen, fALSe)</span><br><span class="line">        <span class="keyword">while</span> (j &lt; dstPtrs(i + <span class="number">1</span>)) &#123;</span><br><span class="line">          <span class="keyword">val</span> dstBlockId = encoder.blockId(dstEncodedIndices(j))</span><br><span class="line">          <span class="keyword">if</span> (!seen(dstBlockId)) &#123;</span><br><span class="line">            activeIds(dstBlockId) += i <span class="comment">// add the local index in this out-block</span></span><br><span class="line">            seen(dstBlockId) = <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          j += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      activeIds.map &#123; x =&gt;</span><br><span class="line">        x.result()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.setName(prefix + <span class="string">"OutBlocks"</span>)</span><br><span class="line">      .persist(storageLevel)</span><br><span class="line">    (inBlocks, outBlocks)  <span class="comment">//返回结果</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="inblock-compress"><a href="#inblock-compress" class="headerlink" title="inblock compress"></a>inblock compress</h4><p>  对inblock 中间结果压缩存储，返回结果格式为（uniqueSrcId数组, dstPtrs数组, dstEncodedIndices数组, ratings数组）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span></span>(): <span class="type">InBlock</span>[<span class="type">ID</span>] = &#123;</span><br><span class="line">  <span class="keyword">val</span> sz = length</span><br><span class="line">  assert(sz &gt; <span class="number">0</span>, <span class="string">"Empty in-link block should not exist."</span>)</span><br><span class="line">  sort()</span><br><span class="line">  <span class="keyword">val</span> uniqueSrcIdsBuilder = mutable.<span class="type">ArrayBuilder</span>.make[<span class="type">ID</span>]</span><br><span class="line">  <span class="keyword">val</span> dstCountsBuilder = mutable.<span class="type">ArrayBuilder</span>.make[<span class="type">Int</span>]</span><br><span class="line">  <span class="keyword">var</span> preSrcId = srcIds(<span class="number">0</span>)</span><br><span class="line">  uniqueSrcIdsBuilder += preSrcId</span><br><span class="line">  <span class="keyword">var</span> curCount = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">  <span class="comment">//得到去重后的src id数组， 以及每个src id的数量</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; sz) &#123;</span><br><span class="line">    <span class="keyword">val</span> srcId = srcIds(i)</span><br><span class="line">    <span class="keyword">if</span> (srcId != preSrcId) &#123;</span><br><span class="line">      uniqueSrcIdsBuilder += srcId</span><br><span class="line">      dstCountsBuilder += curCount</span><br><span class="line">      preSrcId = srcId</span><br><span class="line">      j += <span class="number">1</span></span><br><span class="line">      curCount = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    curCount += <span class="number">1</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  dstCountsBuilder += curCount</span><br><span class="line">  <span class="keyword">val</span> uniqueSrcIds = uniqueSrcIdsBuilder.result()</span><br><span class="line">  <span class="keyword">val</span> numUniqueSrdIds = uniqueSrcIds.length</span><br><span class="line">  <span class="keyword">val</span> dstCounts = dstCountsBuilder.result()</span><br><span class="line">  <span class="keyword">val</span> dstPtrs = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](numUniqueSrdIds + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="comment">//将src id和dst id关系通过dstPtrs进行压缩存储</span></span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; numUniqueSrdIds) &#123;</span><br><span class="line">    sum += dstCounts(i)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    dstPtrs(i) = sum</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">InBlock</span>(uniqueSrcIds, dstPtrs, dstEncodedIndices, ratings)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="computeFactor"><a href="#computeFactor" class="headerlink" title="computeFactor"></a>computeFactor</h3><p>  根据srcFactorBlocks、srcOutBlocks、dstInBlocks, 计算dstFactorBlocks</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">computeFactors</span></span>[<span class="type">ID</span>](</span><br><span class="line">    srcFactorBlocks: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">FactorBlock</span>)],</span><br><span class="line">    srcOutBlocks: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">OutBlock</span>)],</span><br><span class="line">    dstInBlocks: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">InBlock</span>[<span class="type">ID</span>])],</span><br><span class="line">    rank: <span class="type">Int</span>,</span><br><span class="line">    regParam: <span class="type">Double</span>,</span><br><span class="line">    srcEncoder: <span class="type">LocalIndexEncoder</span>,</span><br><span class="line">    implicitPrefs: <span class="type">Boolean</span> = fALSe,</span><br><span class="line">    alpha: <span class="type">Double</span> = <span class="number">1.0</span>,</span><br><span class="line">    solver: <span class="type">LeastSquaresNESolver</span>): <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">FactorBlock</span>)] = &#123;</span><br><span class="line">  <span class="keyword">val</span> numSrcBlocks = srcFactorBlocks.partitions.length  <span class="comment">//src block数量</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">YtY</span> = <span class="keyword">if</span> (implicitPrefs) <span class="type">Some</span>(computeYtY(srcFactorBlocks, rank)) <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">  <span class="comment">//根据srcOut，得到每个dstBlock对应的srcBlockID 和srcFactor数组</span></span><br><span class="line">  <span class="keyword">val</span> srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap &#123;</span><br><span class="line">    <span class="keyword">case</span> (srcBlockId, (srcOutBlock, srcFactors)) =&gt;</span><br><span class="line">      </span><br><span class="line">      srcOutBlock.view.zipWithIndex.map &#123; <span class="keyword">case</span> (activeIndices, dstBlockId) =&gt;</span><br><span class="line">        (dstBlockId, (srcBlockId, activeIndices.map(idx =&gt; srcFactors(idx))))</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据dstBlockId 对srcBlockID, array[srcFactor]进行聚合</span></span><br><span class="line">  <span class="keyword">val</span> merged = srcOut.groupByKey(<span class="keyword">new</span> <span class="type">ALSPartitioner</span>(dstInBlocks.partitions.length))</span><br><span class="line">  <span class="comment">//对每个dstBlockID, 计算其中每个dstID对应的隐语义向量</span></span><br><span class="line">  dstInBlocks.join(merged).mapValues &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="type">InBlock</span>(dstIds, srcPtrs, srcEncodedIndices, ratings), srcFactors) =&gt;</span><br><span class="line">      <span class="comment">//得到每个block对应的src factor向量集合</span></span><br><span class="line"><span class="keyword">val</span> sortedSrcFactors = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">FactorBlock</span>](numSrcBlocks)</span><br><span class="line">      srcFactors.foreach &#123; <span class="keyword">case</span> (srcBlockId, factors) =&gt;</span><br><span class="line">        sortedSrcFactors(srcBlockId) = factors</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//对每个dstID, 获取对应的srcFactor及对应rating, 计算该dstID对应的隐语义向量</span></span><br><span class="line">      <span class="keyword">val</span> dstFactors = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Array</span>[<span class="type">Float</span>]](dstIds.length)</span><br><span class="line">      <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">      <span class="keyword">val</span> ls = <span class="keyword">new</span> <span class="type">NormalEquation</span>(rank)</span><br><span class="line">      <span class="keyword">while</span> (j &lt; dstIds.length) &#123;</span><br><span class="line">        ls.reset()</span><br><span class="line">        <span class="keyword">if</span> (implicitPrefs) &#123;</span><br><span class="line">          ls.merge(<span class="type">YtY</span>.get)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> i = srcPtrs(j)</span><br><span class="line">        <span class="keyword">var</span> numExplicits = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; srcPtrs(j + <span class="number">1</span>)) &#123; <span class="comment">//依次得到每个srcFactor及rating值</span></span><br><span class="line">          <span class="keyword">val</span> encoded = srcEncodedIndices(i)</span><br><span class="line">          <span class="keyword">val</span> blockId = srcEncoder.blockId(encoded)</span><br><span class="line">          <span class="keyword">val</span> localIndex = srcEncoder.localIndex(encoded)</span><br><span class="line">          <span class="comment">//sortedSrcFactors通过blockId和localIndex进行索引，得到需要的factor向量。之前这里困惑挺久，一直感觉从srcOut传过来的factor向量只是一个子集，通过localIndex访问不正确，实际上这里的localIndex和srcOut那里存储的localindex是不需要对应的。因为同一个src id 本身的src local index不等于其它block对应的 dst localindex</span></span><br><span class="line">          <span class="keyword">val</span> srcFactor = sortedSrcFactors(blockId)(localIndex)</span><br><span class="line">          <span class="keyword">val</span> rating = ratings(i)</span><br><span class="line">          <span class="keyword">if</span> (implicitPrefs) &#123;</span><br><span class="line">            <span class="comment">// Extension to the original paper to handle b &lt; 0. confidence is a function of |b|</span></span><br><span class="line">            <span class="comment">// instead so that it is never negative. c1 is confidence - 1.0.</span></span><br><span class="line">            <span class="keyword">val</span> c1 = alpha * math.abs(rating)</span><br><span class="line">            <span class="comment">// For rating &lt;= 0, the corresponding preference is 0. So the term below is only added</span></span><br><span class="line">            <span class="comment">// for rating &gt; 0. Because YtY is already added, we need to adjust the scaling here.</span></span><br><span class="line">            <span class="keyword">if</span> (rating &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              numExplicits += <span class="number">1</span></span><br><span class="line">              ls.add(srcFactor, (c1 + <span class="number">1.0</span>) / c1, c1)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ls.add(srcFactor, rating)</span><br><span class="line">            numExplicits += <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">          i += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Weight lambda by the number of explicit ratings based on the ALS-WR paper.</span></span><br><span class="line">        dstFactors(j) = solver.solve(ls, numExplicits * regParam)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      dstFactors</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ALS-模型推荐"><a href="#ALS-模型推荐" class="headerlink" title="ALS 模型推荐"></a>ALS 模型推荐</h2><p><strong>模型参数</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rank: Int,      //隐语义个数</span><br><span class="line">val userFeatures: RDD[(Int, Array[Double])], //user factor数组, 存储user id 及对应的factor向量</span><br><span class="line">val productFeatures: RDD[(Int, Array[Double])]) //item factor数组，存储item id及对应的factor向量</span><br></pre></td></tr></table></figure>
<p><strong>对所有用户进行推荐</strong></p>
<p>调用recommendForAll函数，首先对user向量和item向量分块并以矩阵形式存储，然后对二者做笛卡尔积，并计算每个user和每个item的得分，最终以user为key, 取topK个item及对应的得分，作为推荐结果. 计算topK时借助于小顶堆</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private def recommendForAll(</span><br><span class="line">    rank: Int,</span><br><span class="line">    srcFeatures: RDD[(Int, Array[Double])],</span><br><span class="line">    dstFeatures: RDD[(Int, Array[Double])],</span><br><span class="line">    num: Int): RDD[(Int, Array[(Int, Double)])] = &#123;</span><br><span class="line">  //对user向量和item向量分块并以矩阵形式存储</span><br><span class="line">  val srcBlocks = blockify(rank, srcFeatures)</span><br><span class="line">  val dstBlocks = blockify(rank, dstFeatures)</span><br><span class="line">  //笛卡尔积，依次对每个组合计算user对item的偏好</span><br><span class="line">  val ratings = srcBlocks.cartesian(dstBlocks).flatMap &#123;</span><br><span class="line">    case ((srcIds, srcFactors), (dstIds, dstFactors)) =&gt;</span><br><span class="line">      val m = srcIds.length</span><br><span class="line">      val n = dstIds.length</span><br><span class="line">      val ratings = srcFactors.transpose.multiply(dstFactors)</span><br><span class="line">      val output = new Array[(Int, (Int, Double))](m * n)</span><br><span class="line">      var k = 0</span><br><span class="line">      ratings.foreachActive &#123; (i, j, r) =&gt;</span><br><span class="line">        output(k) = (srcIds(i), (dstIds(j), r))</span><br><span class="line">        k += 1</span><br><span class="line">      &#125;</span><br><span class="line">      output.toSeq</span><br><span class="line">  &#125;</span><br><span class="line">  //根据user id作为key, 得到喜好分数最高的num个item</span><br><span class="line">  ratings.topByKey(num)(Ordering.by(_._2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 对user向量和item向量分块并以矩阵形式存储, 结果的每个元组分别是对应的id数组和factor构成的矩阵</span><br><span class="line">private def blockify(</span><br><span class="line">    rank: Int,</span><br><span class="line">    features: RDD[(Int, Array[Double])]): RDD[(Array[Int], DenseMatrix)] = &#123;</span><br><span class="line">  val blockSize = 4096 // TODO: tune the block size</span><br><span class="line">  val blockStorage = rank * blockSize</span><br><span class="line">  features.mapPartitions &#123; iter =&gt;</span><br><span class="line">    iter.grouped(blockSize).map &#123; grouped =&gt;</span><br><span class="line">      val ids = mutable.ArrayBuilder.make[Int]</span><br><span class="line">      ids.sizeHint(blockSize)</span><br><span class="line">      val factors = mutable.ArrayBuilder.make[Double]</span><br><span class="line">      factors.sizeHint(blockStorage)</span><br><span class="line">      var i = 0</span><br><span class="line">      grouped.foreach &#123; case (id, factor) =&gt;</span><br><span class="line">        ids += id</span><br><span class="line">        factors ++= factor</span><br><span class="line">        i += 1</span><br><span class="line">      &#125;</span><br><span class="line">      (ids.result(), new DenseMatrix(rank, i, factors.result()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ALS推荐实践"><a href="#ALS推荐实践" class="headerlink" title="ALS推荐实践"></a>ALS推荐实践</h1><p>我们的平台是图片社交，每个用户都可以在平台上浏览图片，并进行点赞、评论等。推荐算法主要用于给用户推荐其最可能感兴趣的图片，最终提升用户体验。</p>
<h2 id="离线实验"><a href="#离线实验" class="headerlink" title="离线实验"></a>离线实验</h2><p>我们平台暂时无法得到用户的显式评分数据，但是可以得到用户点击、点赞、评论等相关行为信息。因此，比较适合用隐反馈矩阵分解模型。</p>
<h3 id="构造数据集"><a href="#构造数据集" class="headerlink" title="构造数据集"></a>构造数据集</h3><ul>
<li><p>数据预处理</p>
<p>从2周的用户行为数据中，过滤无行为用户数据，spam图片数据和spam用户数据。</p>
</li>
<li><p>构建rating元素</p>
<p>对预处理之后的数据，根据用户每天的图片交互行为，分别对点击、点赞和评论等分别赋予不同的权值，得到rating矩阵. </p>
</li>
<li><p>生成训练集和测试集</p>
<p>对于得到的rating数据，随机划分为两部分 $A:B = 7:3$，如果分别直接作为训练集和测试集是有问题的，因为$B$中的user或者item是有可能在$A$中没有出现过，这样会影响评估结果。 我们采用的方法是如果B数据中某个rating元素的user或item没有在A出现，则将该元素放到$A$中用作训练集。最终$A$和新加进来的元素共同构成训练集$A^1$， $B$留下的数据 $B^1$ 作为测试集。</p>
</li>
</ul>
<h3 id="离线训练和评估"><a href="#离线训练和评估" class="headerlink" title="离线训练和评估"></a>离线训练和评估</h3><ul>
<li>离线训练</li>
</ul>
<p>利用spark mllib库，对训练集构成的rating矩阵，建立隐反馈矩阵分解模型，并完成进行矩阵分解，生成user factor和item factor。</p>
<ul>
<li>评估</li>
</ul>
<p>调用模型的recommendForAll函数，对测试集所有user进行item推荐，并计算召回率和准确率。根据召回率和准确率，进行参数优化。</p>
<ul>
<li>评估指标</li>
</ul>
<p>假定$P_i$为用户$i$的预测结果，$P$为所有的预测结果，每个结果记录格式为（user, item）， $T$为测试集,每条记录格式为（user， item）。各种指标的的计算如下：</p>
<p>召回率: $R= \frac{|P \bigcap T|}  {|T|}$</p>
<p>准确率: $P= \frac{|P \bigcap T|}  {|P|}$</p>
<p>F1:  $F= \frac{2PR}  {P+R} $</p>
<p>离散度：$\frac{1}{N^2}\sum_i\sum_j\frac{|P_i \bigcap P_j|}{|P_i \bigcup P_j|}$</p>
<p>除了上述指标之外，我们还对用户连续多天推荐结果的差异性、用户覆盖率、图片覆盖率等指标进行评估。</p>
<h2 id="在线ab测试"><a href="#在线ab测试" class="headerlink" title="在线ab测试"></a>在线ab测试</h2><p>abtest方案： 将als算法计算出的结果，定期写入到线上，作为线上的一种推荐来源。对实验组用户同时采用新策略和旧策略进行推荐，对照组用户只采用旧策略进行推荐。</p>
<p>从2个维度进行评估：</p>
<ul>
<li>评估实验组和对照组用户在abtest上线前后点击率</li>
<li>评估实验组用户在新旧两种策略推荐图片的点击率</li>
</ul>
<p>测试一定时间后，交换对照组和实验组用户，按照上述2个维度重新进行评估</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>【1】Y Koren，R Bell，C Volinsky, “Matrix Factorization Techniques for Recommender Systems”, 《Computer》, 2009.08; 42(8):30-37 </p>
<p>【2】洪亮劼, “知人知面需知心——人工智能技术在推荐系统中的应用”, 2016.11, <a href="http://mp.weixin.qq.com/s/JuaM8d52-f8AzTjEPnCl7g" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/JuaM8d52-f8AzTjEPnCl7g</a></p>
<p>【3】S. Funk, “Netflix Update: Try This at Home”, 2006.12, <a href="http://sifter.org/~simon/journal/20061211.html" target="_blank" rel="noopener">http://sifter.org/~simon/journal/20061211.html</a></p>
<p>【4】Y. Koren, “Factorization Meets the Neighborhood: A Mul-tifaceted Collaborative Filtering Model”, Proc. 14th ACM SIGKDD Int’l Conf. Knowledge Discovery and Data Mining, ACM Press, 2008, pp.426-434</p>
<p>【5】A. Paterek, “Improving Regularized Singular Value De-composition for Collaborative Filtering” Proc. KDD Cup and Workshop, ACM Press, 2007, pp.39-42</p>
<p>【6】G. Takács et al., “Major Components of the Gravity Recom- mendation System”, SIGKDD Explorations, 2007.09, vol.9, pp.80-84</p>
<p>【7】孟祥瑞, “ALS 在 Spark MLlib 中的实现”, 2015.05, <a href="http://www.csdn.net/article/2015-05-07/2824641" target="_blank" rel="noopener">http://www.csdn.net/article/2015-05-07/2824641</a></p>
<p>【8】Zhen-ming Yuan, et al., “A microblog recommendation algorithm based on social tagging and a temporal interest evolution model”, Frontiers of Information Technology &amp; Electronic Engineering, 2015.07,<br>Volume 16, Issue 7, pp 532–540 </p>
<p>【9】Z Zhao, Z Cheng, L Hong, EH Chi, “Improving User Topic Interest Profiles by Behavior Factorization”, Proceedings of the 24th International Conference on World Wide Web, 2015.05, pp.1406-1416</p>
<p>【10】阿里技术，”淘宝搜索/推荐系统背后深度强化学习与自适应在线学习的实践之路”, 2017.02, <a href="http://url.cn/451740J" target="_blank" rel="noopener">http://url.cn/451740J</a></p>
<p>【11】HT Cheng, L Koc, J Harmsen, T Shaked, “Wide &amp; Deep Learning for Recommender Systems”, Proceedings of the 1st Workshop on Deep Learning for Recommender Systems, 2016.09,  pp.7-10</p>
<p>【12】黄安埠, “递归的艺术 - 深度递归网络在序列式推荐的应用”, 2016.10, <a href="http://mp.weixin.qq.com/s?__biz=MzA3MDQ4MzQzMg==&amp;mid=2665690422&amp;idx=1&amp;sn=9bd671983a85286149b51c908b686899&amp;chksm=842bb9b1b35c30a7eedb8d03e173aa8f43465db90e11075ac0c73b1784582f21eb93dcbd3e65&amp;scene=0%23wechat_redirect" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MzA3MDQ4MzQzMg==&amp;mid=2665690422&amp;idx=1&amp;sn=9bd671983a85286149b51c908b686899&amp;chksm=842bb9b1b35c30a7eedb8d03e173aa8f43465db90e11075ac0c73b1784582f21eb93dcbd3e65&amp;scene=0%23wechat_redirect</a></p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/推荐算法/" rel="tag">#推荐算法</a>
          
            <a href="/tags/协同过滤/" rel="tag">#协同过滤</a>
          
            <a href="/tags/矩阵分解/" rel="tag">#矩阵分解</a>
          
            <a href="/tags/隐语义模型/" rel="tag">#隐语义模型</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/07/decision_tree/" rel="next" title="spark mllib 决策树算法源码学习">
                <i class="fa fa-chevron-left"></i> spark mllib 决策树算法源码学习
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/16/gender_based_rs/" rel="prev" title="一种基于性别的推荐方法">
                一种基于性别的推荐方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lantian" />
          <p class="site-author-name" itemprop="name">lantian</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ALS算法模型"><span class="nav-number">1.</span> <span class="nav-text">ALS算法模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要用ALS模型"><span class="nav-number">1.1.</span> <span class="nav-text">为什么要用ALS模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ALS模型有什么缺点"><span class="nav-number">1.2.</span> <span class="nav-text">ALS模型有什么缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ALS模型是什么"><span class="nav-number">1.3.</span> <span class="nav-text">ALS模型是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">1.3.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标函数"><span class="nav-number">1.3.2.</span> <span class="nav-text">目标函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标函数求解"><span class="nav-number">1.3.3.</span> <span class="nav-text">目标函数求解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spark-ALS源码理解"><span class="nav-number">2.</span> <span class="nav-text">spark ALS源码理解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ALS-模型训练"><span class="nav-number">2.1.</span> <span class="nav-text">ALS 模型训练</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ALS-伴生类"><span class="nav-number">2.1.1.</span> <span class="nav-text">ALS 伴生类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ALS-私有类"><span class="nav-number">2.1.2.</span> <span class="nav-text">ALS 私有类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NewALS-train方法"><span class="nav-number">2.1.3.</span> <span class="nav-text">NewALS.train方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建哈希器"><span class="nav-number">2.1.4.</span> <span class="nav-text">构建哈希器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建地址编码解码器"><span class="nav-number">2.1.5.</span> <span class="nav-text">构建地址编码解码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#partition-rating"><span class="nav-number">2.1.6.</span> <span class="nav-text">partition rating</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造in-block-和out-block"><span class="nav-number">2.1.7.</span> <span class="nav-text">构造in_block, 和out_block</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#inblock-compress"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">inblock compress</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#computeFactor"><span class="nav-number">2.1.8.</span> <span class="nav-text">computeFactor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ALS-模型推荐"><span class="nav-number">2.2.</span> <span class="nav-text">ALS 模型推荐</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ALS推荐实践"><span class="nav-number">3.</span> <span class="nav-text">ALS推荐实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#离线实验"><span class="nav-number">3.1.</span> <span class="nav-text">离线实验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造数据集"><span class="nav-number">3.1.1.</span> <span class="nav-text">构造数据集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#离线训练和评估"><span class="nav-number">3.1.2.</span> <span class="nav-text">离线训练和评估</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在线ab测试"><span class="nav-number">3.2.</span> <span class="nav-text">在线ab测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文献"><span class="nav-number">4.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lantian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("L0fIeSgn4Q8LXNCF4L3zEpU7-gzGzoHsz", "MKiQArcDI3O3uBaLP8MaDXw3");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
